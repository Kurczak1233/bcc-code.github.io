import{_ as e,o as i,c as t,f as o}from"./app.1ded8a6d.js";const a={},n=o('<h2 id="context" tabindex="-1"><a class="header-anchor" href="#context" aria-hidden="true">#</a> Context</h2><p>Members 2.0 was developed as an application for managing person data and organizational membership as well as facilitating sharing of data with other systems in a GDPR-compliant manner. During the initial development fase, there has been a heavy focus on UX and the application experience, and less of a focus on the maturity of back-end services and APIs. This has given many &quot;quick&quot; wins, however in this second development fase the focus will be on creating stable and mature backend-services that can be used to provide value and enable other teams to deliver applications/services that are dependent on person, organization and membership data.</p><h3 id="current-issues-and-symptoms" tabindex="-1"><a class="header-anchor" href="#current-issues-and-symptoms" aria-hidden="true">#</a> Current Issues and Symptoms</h3><h4 id="brainstorm-from-workshop" tabindex="-1"><a class="header-anchor" href="#brainstorm-from-workshop" aria-hidden="true">#</a> Brainstorm (from workshop)</h4><ol><li>Users without a membership can&#39;t log in</li><li>No support for multiple addresses (work/private etc.)</li><li>Legacy integrations - no public API</li><li>Access to BCC systems limited to members</li><li>Managing data access (GDPR) possibly overcomplicated</li><li>Data deletion webhooks not implemented</li><li>API Landscape is not mapped out and not aligned</li><li>Users are frustrated with amount and complexity of Apps <ul><li>Family registration(profile)</li><li>Look and feel of BCC Apps</li></ul></li><li>Changes are not enfoced on other Applications (e.g. signout)</li><li>Lack of test environment (require access to production)</li><li>5 minute test time</li><li>10 minute Deploy time</li><li>Lacking global roles</li><li>Lacking business specification</li></ol><h4 id="observations" tabindex="-1"><a class="header-anchor" href="#observations" aria-hidden="true">#</a> Observations</h4><ol><li><p>In general, &quot;person&quot; and &quot;membership&quot; is too tightly intertwined to support more flexible scenarios.</p></li><li><p>It is currently difficult to communicate with other teams (changes not enforced) due to:</p><ul><li>no real public / documented API</li><li>no client SDKs</li><li>product/team culture is stronger than organization culture which is reflected in the architecture</li></ul></li><li><p>Somewhat challenging to set up local development environment and gain full insight into current application</p><ul><li>Mix of concerns within application: process, presentation and integration tightly intertwined</li><li>Simple errors would require a fairly high level of project knowledge to fix with current solution (both due to code base size and especially due to mix of concerns in code)</li></ul></li></ol><p><strong>Conlusion</strong>: we need a better separation of concerns (both from a business and technical perspective) and we need a commitment to our public interface.</p><h2 id="decision" tabindex="-1"><a class="header-anchor" href="#decision" aria-hidden="true">#</a> Decision</h2><ol><li><p>Host core APIs related to person, association and organization in one (or few) services (with a public contract). Motivation: clear separaton of concerns, highly reusable services that could form part of multiple processes</p></li><li><p>Create a separate profile service (which interfaces to multiple environments and has a different behavioural concern - Query vs. Command) Motivation: clear separation of concen, possible interface to multiple other source services and many target applications</p></li><li><p>Keep current &quot;feathers&quot; structure as a BFF (for Members) which utilizes the core APIs Motivation: leverage work already done regarding UI, membership processes etc.</p></li><li><p>Long term, it may also make sense to move the &quot;membership processes&quot; from the current &quot;feathers&quot; implementation. This would be specifically useful if membership flows were integrated with other systems. (fase 2)</p></li></ol><h2 id="consequences" tabindex="-1"><a class="header-anchor" href="#consequences" aria-hidden="true">#</a> Consequences</h2><ol><li><p>Need to define and create new services</p></li><li><p>Ideally need a microservice hosting environment (already partially being practiced via Cloud Run in all teams)</p></li><li><p>We need a messaging infrastructure</p></li><li><p>We need a good solution for API documentation / consumption (e.g. Open API - v2, Protobuf, GraphQL, SDKs)</p></li><li><p>Migration of legacy integrations</p></li></ol><h3 id="alternatives" tabindex="-1"><a class="header-anchor" href="#alternatives" aria-hidden="true">#</a> Alternatives</h3><ol><li><p>Cleanup current solution (monolith)</p><ul><li>split presentation and domain layers</li><li>define public API interface(s)</li><li>move out highly unrelated services</li></ul></li><li><p>Move fundamental services to their own APIs (microservice approach)</p><ul><li>integrate current application (front-end) with new backend services</li><li>ensure clean separation of concerns: application (UI), data aggregation (e.g. profile) and process (e.g. change history etc.)</li></ul></li></ol><p><strong>Reasons for Monolith approach</strong> (one code base, one process)</p><ul><li>Rapid development (within team at coding time, not necessarily build time)</li><li>Easier to implement processes (within same team)</li><li>Less network communication (lower latency)</li><li>Easier error tracing within application</li><li>Possibily cheaper to run</li><li>Easier to test</li><li>Less &quot;plumbing&quot;, simpler infrastructure</li></ul><p><strong>Reasons for Microservice approach</strong> (one or multiple code bases, multiple processes)</p><ul><li>Application (UI) can be split from process and data (e.g. the membership &quot;application&quot; and managing members is a completely different concern than replicating person data)</li><li>Rapid development (within organization)</li><li>Allows for more experimentation and chosing tools that are right for the specific job</li><li>Allows for building &quot;stable&quot; services (which don&#39;t undergo continual change). &quot;Once the person database is done, it&#39;s done&quot;.</li><li>Makes testing simpler within the application (smaller, more clearly defined scope) -- although increases need for integration tests.</li><li>&quot;Forces&quot; us to have a high level infrastructure for message exchange (messaging / HTTP etc) -- which could drive cross-team alignment at a high level.</li><li>Makes separation of concerns a more natural focus area during implementation (perhaps easier to avoid &quot;laziliy&quot; mixing concerns due to lack of &quot;time&quot; or experience)</li><li>Makes it more natural to be explicit about our public interface (i.e. commitment to other parts of the team or other teams).</li><li>Makes it easier to &quot;visualize&quot; message flows at a high level (between services) -- although at the cost of more &quot;plumbing&quot;</li><li>Allows individual scaling of services - which <em>can</em> be more cost effective than scaling one huge service</li><li>Allows for part of a process to fail (and be retried) without an entire process failing.</li><li>Allows for interchangeability - easier to replace or decomission a smaller part of the system/infrastructure</li><li>Allows new (smaller) teams to add value, without understanding the entire infrastructure.</li><li>Moves the &quot;infrastructure&quot; concerns away from the application code -- we can standardize on monitoring etc. accross teams</li></ul><p><strong>Pitfalls for Microservice approach</strong></p><ul><li>If the services are too small, or too dependent on many other services: <ol><li>Debugging with be hard - hard to understand the process</li><li>Infrastrucutre overhead will be high - wasted CPU/Memory just for running process</li><li>Latency will be high</li><li>Reliability will be harder to achieve</li><li>Data consistence and integrity may be harder to achieve</li><li>Local development workflow will be slow and complicated</li></ol></li></ul><h4 id="what-do-we-want-to-achieve" tabindex="-1"><a class="header-anchor" href="#what-do-we-want-to-achieve" aria-hidden="true">#</a> What do we want to achieve?</h4><ol><li><p>End-product should be highly coherent</p><ul><li>Design/UX</li><li>Process flow</li><li>Data consistency (e.g. common profile etc.)</li></ul></li><li><p>Services should be developed and deployed individually</p><ul><li>Front-end</li><li>Processes / integrations</li><li>Data</li></ul></li></ol><p>At a high level, there should be easy communication and high coherence between teams. At a low level, there should be very little inter-team dependencies.</p><h4 id="can-we-find-a-sweet-spot" tabindex="-1"><a class="header-anchor" href="#can-we-find-a-sweet-spot" aria-hidden="true">#</a> Can we find a sweet spot?</h4><ul><li><p>Microservices not nanoservices: &quot;Biggish&quot; microservices that are split to reflect concerns</p><blockquote><p>Business domain boundaries Technical: process (business logic, integration), data (source of truth), UI (application, end-user)</p></blockquote></li><li><p>Main principals: high cohesion, low coupling Interpretation - avoid splitting services that have a lot of two-way communication (probably the same business domain).</p></li></ul>',25),r=[n];function s(l,c){return i(),t("div",null,r)}const p=e(a,[["render",s],["__file","01-architecture-for-services-releated-to-members.html.vue"]]);export{p as default};
