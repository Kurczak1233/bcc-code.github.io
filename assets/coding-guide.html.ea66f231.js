import{_ as e,o as t,c as a,f as i}from"./app.1ded8a6d.js";const n={},r=i('<h1 id="bcc-coding-guide" tabindex="-1"><a class="header-anchor" href="#bcc-coding-guide" aria-hidden="true">#</a> BCC Coding Guide</h1><h2 id="_0-purpose" tabindex="-1"><a class="header-anchor" href="#_0-purpose" aria-hidden="true">#</a> 0. Purpose</h2><p>The purpose of this guide is to provide a set of <em>best practices</em> for development of web applications and apps for BCC. Each project has it&#39;s own constraints and requirements, but this is intended to be a good starting point.</p><h2 id="_1-application-security" tabindex="-1"><a class="header-anchor" href="#_1-application-security" aria-hidden="true">#</a> 1. Application Security</h2><h3 id="_1-1-authentication" tabindex="-1"><a class="header-anchor" href="#_1-1-authentication" aria-hidden="true">#</a> 1.1 Authentication</h3><p><em>Authentication</em> relates to identifying a user or client.</p><ul><li><p><strong>Use OAuth 2.0 (client credentials flow) for application-to-application communication.</strong><br> Why: OAuth 2.0 is an industry standard and will allow simple, yet centralized control of which clients are permitted to access which APIs / resources. Clients only have one set of credentials (clientid / clientsecret) for accessing <em>all</em> participating APIs. These credentials are not shared with anybody (not even the token/authentication authority!).</p></li><li><p><strong>Use OpenID Connect for end-user authentication and identification</strong><br> Why: OpenID Connect (OIDC) is an industry standard for single sign on, adding an &quot;identity&quot; layer on top of OAuth 2.0</p></li><li><p><strong>Use OAuth 2.0 (PCKE flow) for end-user consent of access to their resources (APIs)</strong><br> Comment: Combined with OIDC, OAuth allows the end-user to decide if (third party) apps can access resources (APIs) on their behalf. Whereas Open ID Connect identifies the user (authentication), OAuth 2.0 allows the user to delegate API access (authorization).</p></li><li><p><strong>ONLY use shared secrets / API keys / basic authentication between internal services and resources</strong> (i.e. within the bounds of a single application).<br> API keys / shared secrets offer a simple mechanism for authentication (which does not require a central authentication authority, token requests etc.). However, these secrets don&#39;t usually expire and are hard to keep track of (lack governance) and should therefore NOT be used for integration between applications. An appropriate use case would be accessing storage related to a particular service or as an extra layer of security (in addition to network security) between internal services.</p></li></ul><h3 id="_1-2-authorization" tabindex="-1"><a class="header-anchor" href="#_1-2-authorization" aria-hidden="true">#</a> 1.2 Authorization</h3><p><em>Authorization</em> relates to understanding which permissions / access rights an authenticated user or client has.</p><ul><li><p><strong>Use OAuth 2.0 scopes for course-grained authorization</strong><br> Typically scopes should be used to determine which API&#39;s a client application has access to, and perhaps differentiate between different access levels at a very high level (read, write, admin).</p></li><li><p><strong>Fine grained authorization is <em>business logic</em></strong><br> Authorization rules are usually very use-case and system specific and are essentially business logic. They should be implemented in the domain layers of an application rather than the presentation (routing, transport, controllers, UI) layers of an API / application.</p></li><li><p><strong>Don&#39;t centralize authorization management</strong> Since authorization rules are business logic, they shouldn&#39;t be &#39;outsourced&#39; to a centralized &quot;a permissions administration app&quot;. Differentiate between high level / course grained authorization, which should be centralized (to provide governance) and fine-grained, system specific permissions.<br> As a rule of thumb: permissions are specific to your app, should be managed within your app.</p></li></ul><h3 id="_1-3-network-security" tabindex="-1"><a class="header-anchor" href="#_1-3-network-security" aria-hidden="true">#</a> 1.3 Network Security</h3><ul><li><p><strong>Encrypt <em>all</em> public traffic</strong><br> All public network traffic MUST be encrypted (e.g. using SSL).</p></li><li><p><strong>Single cloud deployments simplify security</strong><br> Network and resource security within a single cloud (Azure, GCP etc.) is significantly simplified compared to a multi-cloud deployment. This is because a multi-cloud deployment typically will require exposing internal resources to the Internet as well as the use of shared secrets etc.</p></li></ul><h3 id="_1-4-deployment-security" tabindex="-1"><a class="header-anchor" href="#_1-4-deployment-security" aria-hidden="true">#</a> 1.4 Deployment Security</h3><h2 id="_2-open-apis" tabindex="-1"><a class="header-anchor" href="#_2-open-apis" aria-hidden="true">#</a> 2. Open APIs</h2><p>All new projects should follow an API-first, open API approach. APIs should be complete, and consumable by others.</p><h3 id="_2-1-why-open-apis" tabindex="-1"><a class="header-anchor" href="#_2-1-why-open-apis" aria-hidden="true">#</a> 2.1 Why Open APIs?</h3><p>Providing fully fledged, easily consumable APIs will allow for better collaboration between teams, and open possiblities for new ways of combining data, creating richer user experiences - in short - fostering innovation. Public API&#39;s should not be an <em>afterthought</em>, but are a core part of our development <em>culture</em>.</p><h3 id="_2-2-committing-to-a-public-api" tabindex="-1"><a class="header-anchor" href="#_2-2-committing-to-a-public-api" aria-hidden="true">#</a> 2.2 Committing to a Public API</h3><p>Although there is little technical difference between a Open or &quot;public&quot; API and internal APIs, Open APIs are essentially a commitment to a contract which you can&#39;t easily back out of.</p><ul><li><strong>Models</strong><br> Models should be well thought through. <em>More is less</em> - rather keep the size of your models (and therefore your comittment) small, than committing to large models which you may want to change in future. Carefully consider if changing business requirements may affect the names of the fields you expose over time. E.g. does it make sense to expose &quot;ChurchID&quot; as a field, or should you rather use something more general (and more resilient to change) such as &quot;OrganizationID&quot;?</li></ul><h3 id="_2-3-technologies" tabindex="-1"><a class="header-anchor" href="#_2-3-technologies" aria-hidden="true">#</a> 2.3 <strong>Technologies</strong></h3><ul><li><p><strong>RESTful HTTP-based APIs using JSON</strong> Currently the defacto standard for Open APIs. Lightweight and human-readable.</p></li><li><p><strong>gRPC</strong> A newer binary format which offers better performance, but not human readable.</p></li></ul><hr><h3 id="_2-4-documentation" tabindex="-1"><a class="header-anchor" href="#_2-4-documentation" aria-hidden="true">#</a> 2.4 Documentation</h3><h2 id="_3-application-frameworks" tabindex="-1"><a class="header-anchor" href="#_3-application-frameworks" aria-hidden="true">#</a> 3. Application Frameworks</h2><h3 id="_3-1-front-end" tabindex="-1"><a class="header-anchor" href="#_3-1-front-end" aria-hidden="true">#</a> 3.1 Front-end</h3><h3 id="_3-2-back-end" tabindex="-1"><a class="header-anchor" href="#_3-2-back-end" aria-hidden="true">#</a> 3.2 Back-end</h3>',27),o=[r];function s(c,h){return t(),a("div",null,o)}const d=e(n,[["render",s],["__file","coding-guide.html.vue"]]);export{d as default};
